<H2>AL. Algorithms and Complexity (31 core hours)</H2>
<H3>AL1. Basic algorithmic analysis (core -- 4 hours)</H3>
&nbsp;&nbsp;Asymptotic analysis of upper and average complexity bounds<BR>
&nbsp;&nbsp;Identifying differences among best, average, and worst case behaviors<BR>
&nbsp;&nbsp;Big &quot;O&quot; and little &quot;o&quot; notation<BR>
&nbsp;&nbsp;Standard complexity classes<BR>
&nbsp;&nbsp;Time and space tradeoffs in algorithms<BR>
&nbsp;&nbsp;Using recurrence relations to analyze recursive algorithms<BR>
<H3>AL2. Algorithmic strategies (core -- 6 hours)</H3>
&nbsp;&nbsp;Brute-force algorithms<BR>
&nbsp;&nbsp;Greedy algorithms<BR>
&nbsp;&nbsp;Divide-and-conquer<BR>
&nbsp;&nbsp;Backtracking<BR>
&nbsp;&nbsp;Branch-and-bound<BR>
&nbsp;&nbsp;Heuristics<BR>
&nbsp;&nbsp;Pattern matching and string/text algorithms<BR>
&nbsp;&nbsp;Numerical approximation algorithms<BR>
<H3>AL3. Fundamental computing algorithms (core -- 12 hours)</H3>
&nbsp;&nbsp;Simple numerical algorithms<BR>
&nbsp;&nbsp;Sequential and binary search algorithms<BR>
&nbsp;&nbsp;Quadratic sorting algorithms (selection, insertion)<BR>
&nbsp;&nbsp;O(N log N) sorting algorithms (Quicksort, heapsort, mergesort)<BR>
&nbsp;&nbsp;Hash tables, including collision-avoidance strategies<BR>
&nbsp;&nbsp;Binary search trees<BR>
&nbsp;&nbsp;Representations of graphs (adjacency list, adjacency matrix)<BR>
&nbsp;&nbsp;Depth- and breadth-first traversals<BR>
&nbsp;&nbsp;Shortest-path algorithms (Dijkstra's and Floyd's algorithms)<BR>
&nbsp;&nbsp;Transitive closure (Floyd's algorithm)<BR>
&nbsp;&nbsp;Minimum spanning tree (Prim's and Kruskal's algorithms)<BR>
&nbsp;&nbsp;Topological sort<BR>
<H3>AL4. Distributed algorithms  (core -- 3 hours)</H3>
&nbsp;&nbsp;Consensus and election<BR>
&nbsp;&nbsp;Termination detection<BR>
&nbsp;&nbsp;Fault tolerance<BR>
&nbsp;&nbsp;Stabilization<BR>
<H3>AL5. Basic computability theory (core -- 6 hours)</H3>
&nbsp;&nbsp;Finite-state machines<BR>
&nbsp;&nbsp;Context-free grammars<BR>
&nbsp;&nbsp;Uncomputable functions<BR>
&nbsp;&nbsp;The halting problem<BR>
&nbsp;&nbsp;Implications of uncomputability<BR>
<H3>AL6. The complexity classes P and NP</H3>
&nbsp;&nbsp;Tractable and intractable problems<BR>
&nbsp;&nbsp;Definition of the classes P and NP<BR>
&nbsp;&nbsp;NP-completeness (Cook's theorem)<BR>
&nbsp;&nbsp;Standard NP-complete problems<BR>
&nbsp;&nbsp;Reduction techniques<BR>
<H3>AL7. Automata theory</H3>
&nbsp;&nbsp;Deterministic finite automata (DFAs)<BR>
&nbsp;&nbsp;Nondeterministic finite automata (NFAs)<BR>
&nbsp;&nbsp;Equivalence of DFAs and NFAs<BR>
&nbsp;&nbsp;Regular expressions<BR>
&nbsp;&nbsp;The pumping lemma for regular expressions<BR>
&nbsp;&nbsp;Push-down automata (PDAs)<BR>
&nbsp;&nbsp;Relationship of PDAs and context-free grammars<BR>
&nbsp;&nbsp;Properties of context-free grammars<BR>
&nbsp;&nbsp;Turing machines<BR>
&nbsp;&nbsp;Nondeterministic Turing machines<BR>
&nbsp;&nbsp;Sets and languages<BR>
&nbsp;&nbsp;Chomsky hierarchy<BR>
<H3>AL8. Advanced algorithmic analysis</H3>
&nbsp;&nbsp;Amortized analysis<BR>
&nbsp;&nbsp;Online and offline algorithms<BR>
&nbsp;&nbsp;Randomized algorithms<BR>
&nbsp;&nbsp;Dynamic programming<BR>
&nbsp;&nbsp;Combinatorial optimization<BR>
<H3>AL9. Cryptographic algorithms</H3>
&nbsp;&nbsp;Historical overview of cryptography<BR>
&nbsp;&nbsp;Private-key cryptography and the key-exchange problem<BR>
&nbsp;&nbsp;Public-key cryptography<BR>
&nbsp;&nbsp;Digital signatures<BR>
&nbsp;&nbsp;Security protocols<BR>
&nbsp;&nbsp;Applications (zero-knowledge proofs, authentication, and so on)<BR>
<H3>AL10. Geometric algorithms</H3>
&nbsp;&nbsp;Line segments: properties, intersections<BR>
&nbsp;&nbsp;Convex hull finding algorithms<BR>
