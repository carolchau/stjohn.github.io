<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html><head>  <title>FAQ's for Final Exam for CSc 75010, Graduate Center, CUNY, Spring 2002</title>  </head><body bgcolor="#ffffff" link="#003399" vlink="#236b8e"><h1>Frequently Asked Questions for Final Exam</h1><h2>Computer Science 75010: Theoretical Computer Science<br>Graduate Center, City University of New York<br>Spring 2002</h2><ul><!--
    <li> The answer key for exam 1: <a href="exam1key.ps">postscript</a>,
		<a href="exam1key.pdf">pdf</a>
    <li><a href="exam1/exam1comments.html">Comments</a> on Exam I (including exam averages)<br>
</li><li>The various versions of the exam given:<br clear="all">
    <ul>
      <li><a href="exam1/exam1sample.pdf">Sample exam</a></li>
      <li><a href="exam1/exam1blue.pdf">Blue version</a></li>
      <li><a href="exam1/exam1green.pdf">Green version</a></li>
      <li><a href="exam1/exam1pink.pdf">Pink version</a></li>
      <li><a href="exam1/exam1yellow.pdf">Yellow version</a><br>
      </li>
    </ul>
  </li>
--></ul><br><br><ol>    <li><font face="Courier New, Courier, monospace">When I review the questions in the exam package,I am<br>not clear about some concepts, could you kindly help<br>me? Thank you!<br>1. recursively enumerable, recognizable and<br>&nbsp;&nbsp; acceptable&nbsp; are same?</font><br>    <br>Recursively enumerable (or r.e.) and Turing-recognizable<br>are the same.&nbsp; Acceptable refers to languages that are<br>accepted by a Finite State Automata (vs. a TM for the<br>other terms). <br clear="all">&nbsp;</li>  <li><font face="Courier New, Courier, monospace">unsolvability is same meaning as undecidable?</font><br>    <br>Yes, our book uses them interchangeably.<br clear="all"> &nbsp;</li>  <li><font face="Courier New, Courier, monospace">Re: question "State Church's Thesis"<br>&nbsp;&nbsp; there is only one sentence in book about it:"The<br>connection between the informal notion of algorithm<br>and the precise definiton is called church-turing<br>thesis". Is it enough to answer this question in the<br>exam?</font><br>    <br>Yes.&nbsp; But for the exam in June, you should read the<br>extra information about Church's thesis on the<br>webpage.<br clear="all"> &nbsp;</li>  <li><font face="Courier New, Courier, monospace">TOT is not recursive, but recursivly enumerable,<br>&nbsp;&nbsp; AM I Right?<br>    </font><br>TOT is not recursive (by reduction to the halting<br>problem).&nbsp; For TOT to be r.e., you would need to<br>construct a TM that recognizes it...<br>    <br>  </li>  <li><font face="Courier New, Courier, monospace">Re question : "Give an example of an uncomputable<br>function which is not defined for some natural<br>numbers"</font><br>    <br>How about f(x) is \phi_x(x) if \phi_x(x) halts and<br>0 otherwise.&nbsp; That's a function from the natural numbers<br>to the natural numbers which doesn't halt (if it did then<br>you could decide the Halting Problem).<br>    <br>    <br>  </li>  <li><font face="Courier New, Courier, monospace">my answer:I think "partial recursive function" is<br>called "uncomputable function", am I right? , so I<br>think function f is one correct example for this<br>question:<br>f=1 if TM M accepts w;<br>&nbsp; undefined if TM M not accepts w.<br>Am I right?</font><br>    <br>No, a partial recursive function is a function that is<br>computable by a TM, but maybe not halt for all inputs.<br>If a function is computable by at TM and halts for all<br>inputs, then it's called a (total) recursive function.<br>    <br>Your example is correct-- you can find a TM that<br>computes f when defined and doesn't halt when f<br>isn't defined.<br>    <br>  </li>  <li><font face="Courier New, Courier, monospace">what is "Dove Tailing"--it means pigeonhole&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp; principle?</font><br clear="all">&nbsp;<br clear="all">Dovetailing and the pigeonhole principle are very different things. &nbsp;<br clear="all">Dovetailingrefers to the interleaving of computations together <br clear="all">(see for example theproof that if a set and its complement are r.e. then it's recursive). &nbsp;<br clear="all">Thepigeonhole principle says that if there's n things and k holes, <br clear="all">with n &gt;k, then at least one hole must contain more than one thing.<br clear="all"> &nbsp;</li>  <li><font face="Courier New, Courier, monospace">I think there exists an effiecitve enumeration of<br>all total recursive functions, since all deciders are<br>coutable --AM I right?</font><br clear="all">    <br clear="all">Since the set of recursive functions is countable, there is an enumeration.&nbsp;<br clear="all">However, this question asks if there is an effective (that is computable)    <br clear="all">way to enumerate all the deciders. &nbsp;How would you build such an enumeration?&nbsp;<font face="Courier New, Courier, monospace"> <br>    </font><br>  </li>  <li><font face="Courier New, Courier, monospace">I read notes and book carefully, but I am still not<br>very clear about below type of questions:<br>Ri is re set and fei i is partial recursive function<br>with index i, which of following are recursive or re<br>or neither?:<br>a. {i| Ri is not empty}- is re but not recursive, am I<br>right?</font><br> <br> Yes.<br><font face="Courier New, Courier, monospace"><br>b. {i| Ri is empty }- is recursive, am I right?<br></font><br>Think about what this would mean.  See Theorem 5.2 on p 173.<font face="Courier New, Courier, monospace"><br><br>c.{i| Ri is all re sets}- is recursive, am I right?<br><br>    </font>Not sure how "R_i is all re sets?"  Do you mean to write <br>{i | R_i is re}?  Is so, then you have the natural numbers whichis recursive. <br clear="all">&nbsp;  </li>  <li><font face="Courier New, Courier, monospace">but, professor,how to analize the below questions(June<br>6)?<br>    <br>d.{x| (exist some y)(y^3+y^2+y -3 =2x)}<br>e. {x| feix(y) not equal to x, for all y}</font><br>    <br>Please include the year or the rest of the description of this problem. &nbsp;<br clear="all">Notethat the first is a polynomial-- thinking back to the only time we <br clear="all">discussedpolynomials (Hilbert's Tenth Problem), what do you know <br clear="all">about polynomialsin one and in more than one variable? &nbsp;For the <br clear="all">second part, think aboutsets such as Tot and Const. &nbsp;How did you <br clear="all">analyze them? <br clear="all">&nbsp;    </li><li><font face="Courier New, Courier, monospace">How to provethat N be the set of natural numbers, and assume ABCD are disjoint, and AU B U C U D = N, Show each of ABCD are recursive.</font><br>    <br>Is there another condition on A, B, C, and D?&nbsp; If A, B, C, and D are r.e, then you could dovetail<br>the machines that enumerate each to create enumerator for the complements of each.<br>If there are no other conditions on A, B, C, and D, then you can't show they're recursive.<br><br>Several students wrote to say that A, B, C, and D are r.e.  Note that if they are as Dmitriy elaborates on above:    <br><br><font face="Courier New, Courier, monospace">This was question #3 on 2001 exam.  Thesets A, B, C, and D are in fact r.e.  A simple TM machine can check if theinput is a valid natural number and then check all numbers in the set (sayA) to see if the number belongs to it.  If the number is not in the set andthe set is infinite then the machine will loop forever, otherwise it willhalt.  Dovetailing four such machines (one for each set) can be used decideany one of the sets.</font><br clear="all">    <font face="Courier New, Courier, monospace"> &nbsp;</font></li><li><font face="Courier New, Courier, monospace">In the homework problem 5.18 on p. 195 which says: "Show that PCP is<br>undecidable over the binary alphabet {0,1}"&nbsp; is it enough to say that since<br>PCP is not decidable over an alphabete that contains more than two symbols<br>and any alphabet can be reduced to a binary form, PCP is undecidable over a<br>binary alphabet?</font><br>    <br>You need to give more detail for this, giving the idea and a sketch of the<br>proof of why PCP is undecidable over a binary alphabet.<br>  </li></ol><br><br><br><small><small>(Last updated: Thursday, 12 December 2002)</small></small><br><br><br><br></body></html>